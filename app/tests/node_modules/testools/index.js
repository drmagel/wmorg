// Set of APIs only for the tests
// Will be run inside Jasmine
// The db Object will be passed from the testcase as well

// Globals
var smtp = require('smtp')
  , ldap  = require('ldap')
  , trans = require('translate')
  , config = require('config').globals
  , reason = require('config').reasons
  , users = require('models')('users')
  , session = require('models')('sessions')
  , groupadmin = require('models')('groupadmins')
  , count = require('models')('counters')
  , lock  = require('models')('lockedusers')
  , applications  = require('models')('applications')
  , apparchive  = require('models')('apparchive')
  , transactions  = require('models')('transactions')
  , transarchive  = require('models')('transarchive')
  , plans = require('models')('plans')
  , pendants = require('models')('pendants')
  , enrolls = require('models')('enrolls')
  ;

// Helpers
exports.setDB = function(db){
  users.setDB(db);
  groupadmin.setDB(db);
  session.setDB(db);
  count.setDB(db);
  lock.setDB(db);
  applications.setDB(db);
  apparchive.setDB(db);
  transactions.setDB(db);
  transarchive.setDB(db);
  plans.setDB(db);
  pendants.setDB(db);
  enrolls.setDB(db);
}

// TEST TOOLS Heplers

function createApplication(Application, callback){
  var callback = callback || function(){};
  count.get('appID', function(e,r){
  if(e){return console.error("TT:"+tt+":count.get: "+e)};
    Application.appID = r.value.seq;
    applications.insert(Application, function(e,r){
      if(e){return console.error("TT:"+tt+":applications.insert: "+e)};
      delete Application._id;
      return callback(Application);
    });
  });
};

function archiveApplication(Application, callback){
  var callback = callback || function(){};
  applicaitons.remove(Application.appID, function(e){
    if(e){return console.error("BATCH:"+tt+":applicaitons.remove: "+e)};
    Application.archiveDateDate = new Date().getTime();
    apparchive.insert(Application, function(e){});
      if(e){return console.error("BATCH:"+tt+":apparchive.insert: "+e)};
      delete Application._id;
      return callback(Application);
  });
};

function generateDate(num){
  var num = num || 0
    , delay = 2 // initial number of days ago
    , d = new Date()
    , d = new Date(d.setDate(d.getDate() - delay))
    ;
    if(num){d = new Date(d.setMonth(d.getMonth() - num))}
  return  d.getTime();
};

// TEST TOOLS APIs

exports.createLoanApplication = function(data, callback){
  var tt = 'createLoanApplication'
  , d = new Date()
  , locale = "en-us"
  , today = new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"}))
  ;

/***
  applications = { // LOANs
    appID: ,
    userID: ,
    assetAppID: , //Optional, only if ASSET was created 
    amount: ,  // initial app amount
    balance: , // real app amout (goes from 'amount' to 0.00)
    asset: ,   // loaned money which can be collected
    pending: , // pending + balance + asset == amount. From pending to asset only after transaction is closed.
    pendants: [pndID, pndID], // only during the negotiation process. Otherwise pendants: [],
    plan: {
      planID: ,
      interest: , // procents
      duration: 
    },
    transactions: [{transID, amount, status},{}],
    type: 'loan',
    weight: ,
    status: active|freezed|completed|canceled,
    releaseDate: Date.now() + plan.duration
    creationDate: Date.now()
  }
  
  data = { // Provided
    userID: ,
    amount: ,
    plan: {
      planID: ,
      interest: , // procents
      duration: 
    }
  }
***/

/*** data setting ***/
  data.balance = data.balance || 0;
  data.asset = data.amount - data.balance;
  data.pending = 0;
  data.pendants = [];
  data.transactions = [{transID: 0, amount: data.amount, status: 'completed'}];
  data.type = 'loan';
  data.weight = data.weight || 9;
  data.status = data.balance ? 'active' : 'completed';
  data.releaseDate = generateDate();
  data.creationDate = generateDate(data.plan.duration);
  
  createApplication(data, function(application){callback(application)});
}