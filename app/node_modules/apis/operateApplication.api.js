const EventEmitter = require('events');
const emitter = new EventEmitter();

exports.operateApplication = function(req, res){
  var api = 'operateApplication'
    , sessID = req.headers.auth
    , operand // valid values: create, get, getby, cancel
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;

/*  // Application descriptions
  applications = { // LOANs
    appID: ,
    userID: ,
    assetAppID: , //Optional, only if ASSET was created 
    amount: ,  // initial app amount
    balance: , // real app amout (goes from 'amount' to 0.00)
    asset: ,   // loaned money which can be collected
    pending: , // pending + balance + asset == amount. From pending to asset only after transaction is closed.
    pendants: [pndID, pndID], // only during the negotiation process. Otherwise pendants: [],
    plan: {
      planID: ,
      interest: , // procents
      duration: 
    },
    transactions: [{transID, amount, status},{}],
    type: 'loan',
    weight: ,
    status: active|freezed|completed|canceled,
    releaseDate: Date.now() + plan.duration
    creationDate: Date.now(),
    completionDate: date
  }

  applications = { // ASSETs
    appID: ,
    userID: ,
    amount: , // investment * %plan.interest
    balance: , // from amount till 0
    investment: , // loaned amount 
    applications: [{appID, amount},{}], // COLLECT applications created from it.
    type: 'asset',
    status: active|completed,
    creationDate: Date.now(),
    completionDate: date
  }

  applications = { // COLLECTs
    appID: ,
    userID: ,
    assetAppID: , //Optional, only if ASSET was created
    applications: [{appID, amount},{}], // ASSET applications with amounts. This app was created from them.
    amount: ,
    pendants: [pndID, pndID], // only during the negotiation process. Otherwise pendants: [],
    transactions: [{transID, amount, status},{}], 
    type: 'collect',
    weight: ,
    status: active|completed|canceled,
    creationDate: Date.now(),
    completionDate: date
  }
*/

  var d = new Date()
    , locale = "en-us"
    , appID = Number(req.body.appID) || 0
    , filter = req.body.filter || {} 
    , planID = Number(req.body.planID) || 0  // for 'create' operand
    , appType = req.body.type || '' // for 'create' and 'getActiveApps' operands
    , amount = Number(req.body.amount) || 0
    ;
  
//Helpers - moved to helpers.js
//  function createApplication(Application, callback)
//  function archiveApplication(Application, callback)

// APIs
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session.validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID   
      return errResponse(reason.invalidSessid, body, res);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
    } else { // sessID is OK
      switch(operand){
/*** createLoanApplication ***
* 1. Only one applicaiton at a time. List is not supported.
* 2. Checks the plan and create an application
***/
        case 'createLoanApplication':
          var planID = Number(req.body.planID) || 0
            , amount = Number(req.body.amount) || 0
            ;
          if(!!!planID || !!!amount){return res.end()};
          plans.getActive(planID,{planID:1, interest:1, duration:1}, function(e,plan){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!plan){return res.end()}; // Wrong planID. Possible hack attack.
            var today = new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"}))
              , app = {
                  userID: userID,
                  amount: amount,
                  balance: amount,
                  asset: 0,
                  pending: 0,
                  plan: plan,
                  pendants: [],
                  transactions: [],
                  type: 'loan',
                  weight: 1, // from 1 till 9
                  status: 'active',
                  creationDate: d.getTime(),
                  completionDate: 0,
                  releaseDate: new Date(today.setMonth(today.getMonth() + plan.duration)).getTime()
                }
              ;
            createApplication(app, function(loan){
              body.application = loan;
              body.result = true;
              res.json(body);
            });
          }); // plans.getActive
        break;
/*** createCollectApplication ***
* 1. Only one applicaiton at a time. List is not supported.
* 2. Create a COLLECT application.
* 3. Receive the list of ASSETs and:
*   - For each ASSET appID find an application
*     a. check the amount and update it
*     b. insert the COLLECT appID and amount to applications.
***/
        case 'createCollectApplication':
          var amount = Number(req.body.amount) || 0
              , assets = req.body.assets || [] // [{appID, amount},{}]
              , count = assets.length
              , completedAssets = []
              , stillActiveAssets = []
            ;
          if(!!!amount || !!!count){return res.end()};
          assets = assets.map(function(el){return {appID: Number(el.appID), amount: Number(el.amount)}});
          var assetID = assets.map(function(el){return el.appID});
          applications.getUserAssets(userID, assetID, {}, function(e,ua){

            if(e){return res.status(500).json({error: "API:"+api+":applications.getUserAssets: "+e})};
            if(ua.length !== count){return res.end()}; // Some of asset appID are wrong. Possible malicious intrusion
            if( ua.filter(function(el){ // check the correct amount for each asset.
                  return (el.balance < assets.find(function(r){return r.appID === el.appID}).amount);
                }).length){return errResponse(reason.invalidAmount, body, res)};
            var app = {
                  userID: userID,
                  applications: assets,
                  amount: amount,
                  balance: amount,
                  pendants: [], // only during the negotiation process. Otherwise pendants: [],
                  transactions: [], 
                  type: 'collect',
                  weight: 1,
                  status: 'active',
                  creationDate: d.getTime(),
                  completionDate: 0
                };
            createApplication(app, function(clct){
              ua.forEach(function(asset){
                var requestedAmount = assets.find(function(el){return el.appID === asset.appID}).amount;
                asset.balance -= requestedAmount;
                asset.applications.push({appID: clct.appID, amount: requestedAmount});
                if(asset.balance === 0){
                  asset.status = 'completed';
                  asset.completionDate = d.getTime();
                  delete asset.balance;
                  completedAssets.push(asset);
                } else {
                  stillActiveAssets.push(asset);
                };
                if(--count === 0){
                  // update stillActiveAssets
                  stillActiveAssets.forEach(function(as){
                    applications.update(as.appID, as, function(e){
                      if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};
                    })                    
                  }); // stillActiveAssets.forEach
                  // move completedAssets to archive
                  completedAssets.forEach(function(as){
                    archiveApplication(as);
                  }); // completedAssets.forEach
                  // send response
                  body.application = clct;
                  body.result = true;
                  res.json(body);
                }; // count === 0
              }); // forEach
            }); // createApplication
              
          }); // applications.getUserAssets
        break;

/*** create ***
* 1. Only one applicaiton at a time. List is not supported.
* 2. LOAN applicaiton - check the plan and create the app.
* 3. COLLECT applicaiton - just create the app.
* Should be transformed to createLoan and createCollect
* createLoan - just check the plan and create an app.
* createCollect - deal with ASSET applicatios.
        case 'create':
          // Test the parameters
          var planID = Number(req.body.planID) || 0
            , appType = req.body.type || ''
            , amount = Number(req.body.amount) || 0
            ;
          if(amount === 0){return res.end()};
          if(!!!(appType === 'loan' || appType === 'collect')){return res.end()};
          
          var Response =  function(application){
                body.application = application;
                body.result = true;
                res.json(body);
              };
              
          var Application = {
                userID: userID,
                amount: amount,
                balance: amount,
                pendants: [],
                transactions: [],
                type: appType,
                weight: 1, // from 1 till 9
                status: 'active',
                creationDate: d.getTime()
              };

          if (appType == 'loan') {
            if(planID === 0){return res.end()};
            Application.asset = 0;
            Application.pending = 0;
            plans.getActive(planID,{planID:1, interest:1, duration:1}, function(e,p){
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              if(!!!p){return res.end()}; // Wrong planID. Possible hack attack.
              var today = new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"}));
              Application.plan = p;
              Application.releaseDate = new Date(today.setMonth(today.getMonth() + p.duration)).getTime();
              createApplication(Application, Response);
            });           
          } else {
            createApplication(Application, Response);
          };
        break;
***/

/*** cancel ***
* 1. Only one application at a time. Array is not supported
* 2. If there is active transactions, return error. The app can't be canceled.
* 3. If there are pendants (offers):
*   - remove them from the applicaiton
*   - remove them from the other applicaiton
*   - send notification to the other user()
*******
* 4. LOAN application:
*   - If asset == 0, set status 'canceled' and move to archive
*   - Else:
*     a. Create new ASSET application with amount = app.asset
*     b. Move old LOAN applicaiton to archive with the status 'canceled'
* 5. COLLECT application.
*   - If app.amount > 0 (it should be, otherwise applicaton has been archived)
*       a. Create new ASSET application
*       b. Move old COLLECT applicaiton to archive with the status 'canceled'
* 6. ASSET application can't be canceled. It only can be transformed to COLLECT
***/
        case 'cancel':
          if (appID === 0){return res.end()};
          if(!!!Array.isArray(appID)){appID = [].concat(appID)};
          var appCount = appID.length;
          body.appID = [];
          body.application = [];
          
          // Helpers
          function archiveAndCreateAssetApplication(app){
            var appid = Number(app.appID);
              
            // Create an emitter for creating Archived application
            emitter.once('E'+appid, function(archivedApp){
              applications.remove(appid, function(e,r){ // remove the Application, appid == app.appID
                if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              });                                  
              apparchive.insert(archivedApp, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                delete archivedApp._id
                body.appID.push(archivedApp.appID);
                body.application.push(archivedApp);
                if(--appCount === 0){
                  body.result = true;
                  res.json(body);
                }
              });                                       
            });
            var archive = {
                  appID: app.appID,
                  userID: app.userID,
                  amount: app.amount,
                  transactions: app.transactions,
                  plan: app.plan,
                  type: app.type,
                  status: 'canceled',
                  releaseDate: new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"})).getTime(),
                  creationDate: d.getTime()
                };
            var asset = {
                  userID: app.userID,
                  amount: app.amount,
                  investment: app.amount,
                  applications: [],
                  type: 'asset',
                  creationDate: d.getTime(),
                  completionDate: 0
                };
            if(app.type == 'loan'){
              archive.asset = app.asset;
              archive.releaseDate = app.releaseDate;
              asset.amount  = app.asset;
              asset.investment = app.asset;
            };
            if(asset.amount > 0){ // Create new ASSET and then archive the applications
              createApplication(asset, function(a){
                archive.assetAppID = a.appID;
                emitter.emit('E'+appid, archive);
              });
            } else { // Create just Archive application
              emitter.emit('E'+appid, archive);                    
            }; 
          } // function archiveAndCreateAssetApplication(app)

          // The main For loop.  
          appID.forEach(function(appid){
            applications.get(appid, filter, function(e,app){ // get the Applicaton
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              if(!!!app){return res.end()};
              if(app.transactions.filter(function(tr){return tr.status === 'active';}).length > 0){ // MUST be checked in UI;
                body.appID = appid;
                body.application = app;
                return errResponse(reason.activeTransactions, body, res);
              }; // Just test on intruding
              
              var pndCounter = app.pendants.length;
              if(pndCounter > 0){ // There are some pendants
                app.pendants.forEach(function(pndid){ // Get pendants list
                  pendants.get(pndid,{loanAppID:1, clctAppID:1}, function(e,p){
                    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                    if(!!!p){return res.end()};
                    // appid is a Number, p.loanAppID is a String. MUST use either == or toSting().
                    var otherAppID = (appid == p.loanAppID ? p.clctAppID : p.loanAppID); // figure out the other appID
                    applications.get(otherAppID, {pendants:1}, function(e,oa){ 
                      if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                      oa.pendants.splice(oa.pendants.indexOf(pndid),1);
                      applications.update(otherAppID, oa, function(e){ // remove pendant from otherAppID pendants
                        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                      });
                      pendants.remove(pndid, function(e,r){ // remote the pendant itself
                        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                        if (--pndCounter === 0){ // all applicaiton pendants have been removed
                          archiveAndCreateAssetApplication(app);
                        };
                      }); // pendants.remove
                    }); // applications.get
                  }); // pendants.get              
                }); // a.pendants.forEach 
              } else { // No Pendants
                archiveAndCreateAssetApplication(app);
              }
              
            }); // applications.get
          }); // appID.forEach
        break;
        case 'get':
          var filter = req.body.filter || {}
            , appID = Number(req.body.appID) || 0
            ;
          if (appID === 0){return res.end()};
          applications.get(appID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            body.result = true;
            body.appID = appID;
            body.application = r;
            res.json(body);
          });
        break;
        case 'getUserApps':
          var filter = req.body.filter || {};
          applications.getUserApps(userID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!r){return res.end()};
            body.result = true;
            body.appID = r.map(function(el){return el.appID});
            body.application = r;
            res.json(body);
          });
        break;
        case 'getUserAssets':
          var filter = req.body.filter || {}
            , asset = req.body.asset || []
            ;
          applications.getUserAssets(userID, asset, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!r){return res.end()};
            body.result = true;
            body.appID = r.map(function(el){return el.appID});
            body.application = r;
            res.json(body);
          });
        break;
/***
* Used for negotiation process
* Requires applicaiton's type (loan or collect)
* Add user furstName and familyName to the application
* Returns list of applicaiton numbers and list of applications with users names
***/
        case 'getActiveApps':
          var appType = req.body.type || '';
          if(!!!(appType === 'loan' || appType === 'collect')){return res.end()};
          applications.getActiveApps(appType, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!r){return res.end()};
            body.result = true;
            body.appID = r.map(function(el){return el.appID});
            var rCount = r.length;
            r.forEach(function(el){
              users.get(el.userID,{firstName:1, familyName:1}, function(e,u){
                if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                el.user = u;
                if(--rCount === 0){
                  body.application = r;
                  res.json(body);
                };
              });
            });
          });
        break;
//        case '':
//        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
    } // if-else
  }); // session validation
}

