// Set of APIs for all operations
// The view and routers are for Angular.js
// The db Object will be passed as req.db
// The link: /rest/:api will apply api.<:api> which is API name

// Globals
var smtp = require('smtp')
  , ldap  = require('ldap')
  , trans = require('translate')
  , config = require('config').globals
  , reason = require('config').reasons
  , users = require('models')('users')
  , session = require('models')('sessions')
  , groupadmin = require('models')('groupadmins')
  , count = require('models')('counters')
  , lock  = require('models')('lockedusers')
  , applications  = require('models')('applications')
  , apparchive  = require('models')('apparchive')
  , transactions  = require('models')('transactions')
  , transarchive  = require('models')('transarchive')
  , plans = require('models')('plans')
  , pendants = require('models')('pendants')
  , enrolls = require('models')('enrolls')
  ;

// Helpers
exports.setDB = function(db){
  users.setDB(db);
  groupadmin.setDB(db);
  session.setDB(db);
  count.setDB(db);
  lock.setDB(db);
  applications.setDB(db);
  apparchive.setDB(db);
  transactions.setDB(db);
  transarchive.setDB(db);
  plans.setDB(db);
  pendants.setDB(db);
  enrolls.setDB(db);
}


function registrationMail(lang, email, str, num) {
  var tr = trans.init(lang);
  return {
    from: "noreply@amdocs.com",
    to: email,
    subject: tr.tr('thanksForЕnrolling'),
    html: "<body style='tab-interval:.5in'> <div style='direction:"
           + tr.direction() +
          "'> <p class=MsoNormal>"
           + tr.tr('thanksForЕnrollingToWMOrg') +
          "<p class=MsoNormal><o:p>&nbsp;</o:p></p>"
           + tr.tr('theVerificationNumberIs') +
          "<span style='mso-tab-count:1'>   </span>" +
          "<span style='font-size:14.0pt;color:#00B0F0'>"
           + num +
          "<o:p></o:p></span></p><p class=MsoNormal>"
           + tr.tr('theVerificationStringIs') +
          "<span style='mso-tab-count:1'>   </span>" +
          "<span style='font-size:18.0pt;color:#76923C'>"
           + str +
          "</span><p class=MsoNormal><o:p>&nbsp;</o:p></p>"
           + tr.tr('bestRegards') +
          "</p> <p class=MsoNormal>"
           + tr.tr('WMOrgTeam') +
          "</p></div></body>"
  };
};

function errResponse(reason, body, res){
  body.reason = reason;
  body.result = false;
  return res.json(body); 
};

// APIs

exports.createUser = function(req, res){
  var api = 'createuser'
    , body = {};
  if(req.headers.auth === undefined ||
     req.headers.auth !== api){return res.end();}
  res.set('Content-Type', 'application/json');
//------------------------------------------------------
  var User = req.body.user || {}
    , passwd = req.body.password || ''
    , email = req.body.email || ''
    , verNum = req.body.number || 0
    , verStr = req.body.string || ''
    , userID = 0
    ;

  if( Object.keys(User).length === 0 ||    
      passwd === '' ||
      email === '' ||
      verNum === 0 ||
      verStr === ''
    ){return res.end();}

  User.userStatus = 'active';
  User.userRole = [];
  User.userRating = {score: 0, evaluations: 0};
  User.pictureURL = '';
  User.registrationDate = new Date().getTime();
  User.email = email;
  User.groupAdminUserID = 0;

  enrolls.get({email: email, number: verNum, string: verStr}, function(e,r){     
    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
    if(!!!r){return res.end();}     
    count.get('userID', function(e,r){
      if(e){return res.status(500).json({error: "API:"+api+": "+e})};
      userID = r.value.seq;
      ldap.add(email, passwd, userID, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        User.userID = userID;
        users.insert(User, function(e,r){
          if(e){return res.status(500).json({error: "API:"+api+": "+e})};
          delete User._id;
          body.userID = userID;
          session.insert(body, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            enrolls.remove(email);
            delete body._id;
            body.result = true;
//            body.user = User;
            res.set('Auth', body.sessID);
            res.json(body); // response {sessID, userID, result}
          }); // session
        }); // users
      }); // ldap
    }); // count
  }); // enrolls
}


exports.employGroupAdmin = function(req, res){
  var api = 'employGroupAdmin'
    , sessID = req.headers.auth
    , operand = req.query.operand ? req.query.operand : req.body.operand || ''
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ||
       operand === '' ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  var permissions = ['officeAdmin', 'globalAdmin']  // Required permissions for the API execution
    , d = new Date()
    , gradmins = req.body.gradmID || []
    ;

  if(!!!gradmins.toString().length){return res.end()};
  if(!!!Array.isArray(gradmins)){gradmins = [gradmins]};
  var grcounter = gradmins.length;
  body.groupAdmin = [];
  body.areadyAssigned = [];
  body.areadyDischarged = [];
  body.userInactive = [];

//19
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res)
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res)
    } else { // sessID is OK
      users.get(userID, {'userRole':1}, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+":user role: "+e})};
        if(r.userRole.some(function(el){return permissions.indexOf(el) > -1;})){ // user has permission
          switch(operand){
            case 'reqruit':
              gradmins.forEach(function(ID){
                var gradmID = Number(ID);
                users.get(gradmID,
                          {userRole:1, userStatus:1, pictureURL:1, country:1, language:1, firstName:1, familyName:1, phone:1, email:1},
                          function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+":user get: "+e})};
                  if(r.userStatus !== 'active'){
                    body.userInactive.push(ID);
                  } else if(r.userRole.indexOf('groupAdmin') > -1){
                    body.areadyAssigned.push(ID);
                  } else {                      
                    var gradm = {
                          userID: gradmID,
                          firstName: {},
                          familyName: {},
                          pictureURL: r.pictureURL,
                          phone: r.phone,
                          email: r.email,
                          country: r.country,
                          region: [],
                          language: [r.language],
                          members: []
                        }
                      , counter = config.supportedLangsList.length
                      ;
                    config.supportedLangsList.forEach(function(el){
                      if (el.value == r.language){
                        gradm.firstName[el.value] = r.firstName;
                        gradm.familyName[el.value] = r.familyName;                    
                      } else {
                        gradm.firstName[el.value] = '';
                        gradm.familyName[el.value] = '';
                      };
                      if(--counter === 0){
                        groupadmin.insert(gradm, function(e,r){
                          if(e){return res.status(500).json({error: "API:"+api+":groupadmin insert: "+e})};
                        });
                        users.get(gradmID,{userRole:1},function(e,r){
                          if(e){return res.status(500).json({error: "API:"+api+":users get: "+e})};                      
                          r.userRole.push('groupAdmin');
                          users.updateUserRole(gradmID,r.userRole,function(e){                          
                            if(e){return res.status(500).json({error: "API:"+api+":groupadmin updateUserRole: "+e})};
                          })
                        });
                        body.groupAdmin.push(ID);
                      } // counter === 0
                    }); // config.supportedLangsList
                  } // if-else
                  if(--grcounter === 0){
                    body.result = body.groupAdmin.length ? true : false;
                    return res.json(body);                        
                  } // grcounter === 0
                }) // users.get()
              }); // gradmins.forEach 
            break; // reqruit
            case 'discharge':
              gradmins.forEach(function(ID){
                var gradmID = Number(ID);
                users.get(gradmID,{userRole:1, userStatus:1}, function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+":user get: "+e})};
                  if(r.userStatus !== 'active'){
                    body.userInactive.push(ID);
                  } else if(r.userRole.indexOf('groupAdmin') === -1){
                    body.areadyDischarged.push(ID);
                  } else {                    
                    groupadmin.get(gradmID,{members:1}, function(e,r){
                      if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};
                      r.members.forEach(function(uid){
                        users.update(uid,{groupAdminUserID: 2},function(e){
                          if(e){return res.status(500).json({error: "API:"+api+":users update: "+e})};                      
                        });
                      });
                      groupadmin.remove(gradmID,function(e){
                        if(e){return res.status(500).json({error: "API:"+api+":groupadmin remove: "+e})}
                      });
                    })
                    users.get(gradmID,{userRole:1},function(e,r){
                      if(e){return res.status(500).json({error: "API:"+api+":users get: "+e})};
                      users.updateUserRole(
                        gradmID,
                        r.userRole.filter(function(el){return el !== 'groupAdmin'}),
                        function(e){
                          if(e){return res.status(500).json({error: "API:"+api+":groupadmin updateUserRole: "+e})};
                        }
                      )
                    });
                    body.groupAdmin.push(ID);
                    if(--grcounter === 0){
                      body.result = body.groupAdmin.length ? true : false;
                      return res.json(body);                        
                    } // grcounter === 0
                  } // else-if
                }); // users.get()
              }) // gradmins.forEach
            break; // discharge
            case 'updateProfile':
              var data = req.body.data || {};
              if(!!!Object.keys(data).length){return res.end()};
              if(gradmins.length !== 1){return res.end()}; // Only one update at a time.
              var gradmID = gradmins[0];
              users.get(gradmID,{userRole:1, userStatus:1}, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":user get: "+e})};
                if(r.userStatus !== 'active'){
                  body.userInactive.push(gradmID);
                } else if(r.userRole.indexOf('groupAdmin') === -1){
                  body.areadyDischarged.push(gradmID);
                } else {
                  body.groupAdmin.push(gradmID);
                  groupadmin.update(gradmID, data, function(e,r){
                    if(e){return res.status(500).json({error: "API:"+api+":groupadmin update: "+e})};                
                  });
                }
                body.result = body.groupAdmin.length ? true : false;
                return res.json(body);
              })
            break; // updateProfile
            default:
              res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
          } // switch
        } else { // user doesn't have permission
          return errResponse(reason.permissionDenied, body, res)
        }

      }); // users.get()
// 2
    } // if-else
  }); // session validation
}

exports.enroll = function(req, res){
  var api = 'enroll'
    , operand
    , body = {};
  if(req.headers.auth === undefined ||
     req.headers.auth !== api){return res.end();}

  var email = req.body.email || ''
    , verStr = req.body.string || ''
    , verNum = req.body.number || 0
    , lang = req.body.lang || ''
    , phone= req.body.phone || ''
    ;
  res.set('Content-Type', 'application/json');
  res.set('Auth', api);
//------------------------------------------------------
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;

  switch(operand){
  case 'checkEmail':
      if(email === '' || lang === ''){return res.end()};
      users.checkEmail(email,function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        if(r.length){
          body = r[0];
          return errResponse(reason.emailExists, body, res);
//          body.result = false;
//          body.reason = 'email_already_exists';
//          return res.json(body);
        } else {
          var verStr  = Math.random().toString(26).replace(/[^a-z]+/g, '').substr(1,8)
            , verNum  = Math.random().toString().replace(/[^\d]+/g, '').substr(1,8)
            ;
          body.email = email;
          smtp.sendMail(registrationMail(lang, email, verStr, verNum), function(e,r){
            if(e){
              return errResponse(reason.nonExistentEmail, body, res);
//              body.result = false;
//              body.reason = 'non_existent_email';
//              return res.json(body);
            };
            enrolls.insert({email: email, number: verNum, string: verStr}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              body.result = true;
              return res.json(body);
            });
          });  
        }
      });
  break;
  case 'checkPhone':
      if(phone === ''){return res.end()};
      users.checkPhone(phone,function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        if(r.length){
          body = r[0];
          return errResponse(reason.phoneExists, body, res);
//          body.result = false;
//          body.reason = 'phone_already_exists';
//          return res.json(body);
        } else {
          body.result = true;
          return res.json(body);
        }
      });
  break;
  case 'reassert':
      if(email === '' || verStr === '' || verNum === 0 ){return res.end()};
      enrolls.get({email: email, string: verStr, number: verNum},function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        if(!!!r){
          return errResponse(reason.notValid, body, res);
//          body.result = false;
//          body.reason = 'not_valid';
//          return res.json(body);
        }
        body.result = true;
        return res.json(body);
      });
  break;
//        case '':
//        break;
  default:
    res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
} // switch
  
}


exports.getPlans = function(req, res){
  var api = 'getPlans'
    , sessID = req.headers.auth
    , operand // valid values: 'active', 'permanent', 'pending', 'completed', 'all'
    , userID = Number(req.body.userID || 0)
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  var method = ''
    , d = new Date()
    ;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;
  if((operand || '').length === 0){operand = 'active'}; // Set default value to 'active'

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      body.plans = [];
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      body.plans = [];
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // sessID is OK
      switch(operand){
        case 'active': method = 'Active';
        break;
        case 'permanent': method = 'Permanent';
        break;
        case 'pending': method = 'Pending';
        break;
        case 'completed': method = 'Completed';
        break;
        case 'all': method = 'All';
        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      }
      method = 'get'+method+'Plans';
      plans[method](function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        if(r.length > 1){r.sort(function(a,b){return a.planID - b.planID})};
        body.result = true;
        body.plans = r;
        res.json(body);
      });
    } // if-else
  }); // session validation
}


exports.login = function(req, res){
  var api = 'login'
    , body = {}
    ;
  if(req.headers.auth === undefined ||
     req.headers.auth !== api){return res.end();}

  var email = req.body.email || ''
    , passw = req.body.password || ''
    ;
  if(email === '' ||
     passw === ''){return res.end()};
//------------------------------------------------------


  res.set('Content-Type', 'application/json');

  ldap.validate(email, passw, function(data){
      if(data.result){
        body.userID = data.userID;
        session.insert(body, function(e,r){
          if(e){return res.status(500).json({error: "API:"+api+": "+e})};
          delete body._id;
          body.result = data.result;
          res.set('Auth', body.sessID);
          res.json(body);
        });
      } else {
        data.userID = 0;
        res.set('Auth', api);
        res.json(data);
      }
  });
}


exports.logout = function(req, res){
  var api = 'logout'
    , sessID = req.headers.auth
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ) {return res.end()};

  res.set('Content-Type', 'application/json');
  session.remove(sessID, function(e,r){
    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
    body.result = true;
    res.json(body);
  });
}


const EventEmitter = require('events');
const emitter = new EventEmitter();

exports.operateApplication = function(req, res){
  var api = 'operateApplication'
    , sessID = req.headers.auth
    , operand // valid values: create, get, getby, cancel
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;

/*  // Application descriptions
  applications = { // LOANs
    appID: ,
    userID: ,
    assetAppID: , //Optional, only if ASSET was created 
    amount: ,  // initial app amount
    balance: , // real app amout (goes from 'amount' to 0.00)
    asset: ,   // loaned money which can be collected
    pending: , // pending + balance + asset == amount. From pending to asset only after transaction is closed.
    pendants: [pndID, pndID], // only during the negotiation process. Otherwise pendants: [],
    plan: {
      planID: ,
      interest: , // procents
      duration: 
    },
    transactions: [{transID, amount, status},{}],
    type: 'loan',
    weight: ,
    status: active|freezed|completed|canceled,
    releaseDate: Date.now() + plan.duration
    creationDate: Date.now()
  }

  applications = { // ASSETs
    appID: ,
    userID: ,
    amount: , // investment * %plan.interest
    investment: , // loaned amount 
    applications: [{appID, amount},{}], // COLLECT applicaitons created from it.
    type: 'asset',
    status: active|completed,
    creationDate: Date.now()
  }

  applications = { // COLLECTs
    appID: ,
    userID: ,
    assetAppID: , //Optional, only if ASSET was created
    amount: ,
    pendants: [pndID, pndID], // only during the negotiation process. Otherwise pendants: [],
    transactions: [{transID, amount, status},{}], 
    type: 'collect',
    weight: ,
    status: active|completed|canceled,
    creationDate: Date.now()
  }
*/

  var d = new Date()
    , locale = "en-us"
    , appID = Number(req.body.appID) || 0
    , filter = req.body.filter || {} // filter for 'get' operands
    , planID = Number(req.body.planID) || 0  // for 'create' operand
    , appType = req.body.type || '' // for 'create' and 'getActiveApps' operands
    , amount = Number(req.body.amount) || 0
    ;
  
//Helpers
  function createApplication(Application, callback){
    count.get('appID', function(e,r){
    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
      Application.appID = r.value.seq;
      applications.insert(Application, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        delete Application._id;
        callback(Application);
      });
    });
  };

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID   
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // sessID is OK
     switch(operand){
        case 'create':
//console.log('operateApplication:create:amount: '+amount+'; appType: '+appType+'; planID: '+planID);
          // Test the parameters
          if(amount === 0){return res.end()};
          if(!!!(appType === 'loan' || appType === 'collect')){return res.end()};
          
          var Response =  function(application){
                body.application = application;
                body.result = true;
                res.json(body);
              };
              
          var Application = {
                userID: userID,
                amount: amount,
                balance: amount,
                pendants: [],
                transactions: [],
                type: appType,
                weight: 1, // from 1 till 9
                status: 'active',
                creationDate: d.getTime()
              };

          if (appType == 'loan') {
            if(planID === 0){return res.end()};
            Application.asset = 0;
            Application.pending = 0;
            plans.get(planID,{planID:1, interest:1, duration:1}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              if(!!!r){return res.end()}; // Wrong planID. Possible hack attack.
              var today = new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"}));
              Application.plan = r;
              Application.releaseDate = new Date(today.setMonth(today.getMonth() + r.duration)).getTime();
              createApplication(Application, Response);
            });           
          } else {
            createApplication(Application, Response);
          };
          
        break;
        case 'get':
          if (appID === 0){return res.end()};
          applications.get(appID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            body.result = true;
            body.appID = appID;
            body.application = r;
            res.json(body);
          });
        break;
        case 'getUserApps':
          applications.getUserApps(userID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!r){return res.end()};
            body.result = true;
            body.appID = r.map(function(el){return el.appID});
            body.application = r;
            res.json(body);
          });
        break;
        case 'getActiveApps':
          if(!!!(appType === 'loan' || appType === 'collect')){return res.end()};
          applications.getActiveApps(appType, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            if(!!!r){return res.end()};
            body.result = true;
            body.appID = r.map(function(el){return el.appID});
            var rCount = r.length;
            r.forEach(function(el){
              users.get(el.userID,{firstName:1, familyName:1}, function(e,u){
                if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                el.user = u;
                if(--rCount === 0){
                  body.application = r;
                  res.json(body);
                };
              });
            });
          });
        break;
        case 'cancel':
          if (appID === 0){return res.end()};
          if(!!!Array.isArray(appID)){appID = [].concat(appID)};
          var appCount = appID.length;
          body.appID = [];
          body.application = [];
          
          // Helpers
          var archiveAndCreateAssetApplication = function(app){
                var appid = Number(app.appID);
                  
                // Create an emitter for creating Archived application
                emitter.once('E'+appid, function(archivedApp){
                  applications.remove(appid, function(e,r){ // remove the Application, appid == app.appID
                    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                  });                                  
                  apparchive.insert(archivedApp, function(e,r){
                    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                    delete archivedApp._id
                    body.appID.push(archivedApp.appID);
                    body.application.push(archivedApp);
                    if(--appCount === 0){
                      body.result = true;
                      res.json(body);
                    }
                  });                                       
                });
                var archive = {
                      appID: app.appID,
                      userID: app.userID,
                      amount: app.amount,
                      transactions: app.transactions,
                      plan: app.plan,
                      type: app.type,
                      status: 'canceled',
                      releaseDate: new Date(d.toLocaleString(locale, {month: "long", day: "numeric", year: "numeric"})).getTime(),
                      creationDate: d.getTime()
                    };
                var asset = {
                      userID: app.userID,
                      amount: app.amount,
                      investment: app.amount,
                      applicaitons: [],
                      type: 'asset',
                      creationDate: d.getTime()
                    };
                if(app.type == 'loan'){
                  archive.asset = app.asset;
                  archive.releaseDate = app.releaseDate;
                  asset.amount  = app.asset;
                  asset.investment = app.asset;
                };
                if(asset.amount > 0){ // Create new ASSET and then archive the applications
                  createApplication(asset, function(a){
                    archive.assetAppID = a.appID;
                    emitter.emit('E'+appid, archive);
                  });
                } else { // Create just Archive application
                  emitter.emit('E'+appid, archive);                    
                }; 
              } //archiveAndCreateAssetApplication(app)

          // The main For loop.  
          appID.forEach(function(appid){
            applications.get(appid, filter, function(e,app){ // get the Applicaton
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              if(!!!app){return res.end()};
              if(app.transactions.filter(function(tr){return tr.status === 'active';}).length > 0){ // MUST be checked in UI;
                body.appID = (appid);
                body.application = app;
                return errResponse(reason.activeTransactions, body, res);
//                body.result = false;
//                body.reason = 'active_transactions'
//                return res.json(body);
              }; // Just test on intruding
              
              var pndCounter = app.pendants.length;
              if(pndCounter > 0){ // There are some pendants
                app.pendants.forEach(function(pndid){ // Get pendants list
                  pendants.get(pndid,{loanAppID:1, clctAppID:1}, function(e,p){
                    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                    if(!!!p){return res.end()};
                    // appid is a Number, p.loanAppID is a String. MUST use either == or toSting().
                    var otherAppID = (appid == p.loanAppID ? p.clctAppID : p.loanAppID); // figure out the other appID
                    applications.get(otherAppID, {pendants:1}, function(e,oa){ 
                      if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                      oa.pendants.splice(oa.pendants.indexOf(pndid),1);
                      applications.update(otherAppID, oa, function(e){ // remove pendant from otherAppID pendants
                        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                      });
                      pendants.remove(pndid, function(e,r){ // remote the pendant itself
                        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                        if (--pndCounter === 0){ // all applicaiton pendants have been removed
                          archiveAndCreateAssetApplication(app);
                        };
                      }); // pendants.remove
                    }); // applications.get
                  }); // pendants.get              
                }); // a.pendants.forEach 
              } else { // No Pendants
                archiveAndCreateAssetApplication(app);
              }
              
            }); // applications.get
          }); // appID.forEach
        break;
//        case '':
//        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
     }
// 2
    } // if-else
  }); // session validation
}


exports.operateGroup = function(req, res){
  var api = 'operateGroup'
    , sessID = req.headers.auth
    , operand = req.query.operand ? req.query.operand : req.body.operand || ''
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ||
       operand === '' ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------

  var d = new Date()
    , permissions = ['groupAdmin'] // Required permissions for the API execution
    ;

  //19
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      body.result = false;
      body.reason = 'invalid_sessid';
      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      body.result = false;
      body.reason = 'sessid_expired';
      res.json(body);
    } else { // sessID is OK
      users.get(userID, {'userRole':1}, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+":user role: "+e})};
        if(r.userRole.some(function(el){return permissions.indexOf(el) > -1;})){ // user has permission
          switch(operand){
            case 'updateProfile':
              var data = req.body.data || {};
              if(!!!Object.keys(data).length){return res.end()};
              groupadmin.update(userID, data, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":groupadmin update: "+e})};
                groupadmin.get(userID, {}, function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};
                  body.groupadmin = r;                  
                  body.result = true;
                  return res.json(body);
                }); // groupadmin.get()
              }); // groupadmin.update()
            break; // updateProfile
            case 'listGroup':
              groupadmin.get(userID, {members:1}, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};                
                if(!!!r){return errResponse(reason.roleError, body, res)};
                users.getList(r.members, {groupAdminUserID:0, bankAccount:0}, function(e, lst){
                  if(e){return res.status(500).json({error: "API:"+api+":users getList: "+e})};                
                  body.members = lst;
                  body.result = true;
                  return res.json(body);
                }); // users.getList()
              }); // groupadmin.get()
            break; // listGroup
//            case '':
//            break; // 
            default:
              res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
          } // switch
        } else { // user doesn't have permission
          return errResponse(reason.permissionDenied, body, res)
        }
      }); // users.get()
// 2
    } // if-else
  }); // session validation
}

exports.operateGroupAdmin = function(req, res){
  var api = 'operateGroupAdmin'
    , sessID = req.headers.auth
    , operand = req.query.operand ? req.query.operand : req.body.operand || ''
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ||
       operand === '' ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------

  var d = new Date()
    ;

//19
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      body.result = false;
      body.reason = 'invalid_sessid';
      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      body.result = false;
      body.reason = 'sessid_expired';
      res.json(body);
    } else { // sessID is OK
      switch(operand){
        case 'assign':
          var gradmID = Number(req.body.gradmID) || 0;
          if(!!!gradmID){return res.end()};
          groupadmin.get(gradmID, {userID:1}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};
            if(!!!r){return errResponse(reason.roleError, body, res)};
            users.update(userID,{groupAdminUserID: gradmID}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":user update: "+e})};
            });
            groupadmin.addMember(gradmID, userID, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":groupadmin addMember: "+e})};
            });
            body.result = true;
            res.json(body);              
          }) // groupadmin.get
        break;
        case 'fire':
          var gradmID = Number(req.body.gradmID) || 0;
          if(!!!gradmID){return res.end()};
          groupadmin.get(gradmID, {userID:1}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};
            if(!!!r){return errResponse(reason.roleError, body, res)};
            users.update(userID,{groupAdminUserID: 1}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":user update: "+e})};
            });
            groupadmin.delMember(gradmID, userID, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":groupadmin delMember: "+e})};
            });
            body.result = true;
            res.json(body);
          }) // groupadmin.get
          break;
        case 'replace':
          var gradmID = Number(req.body.gradmID) || 0;
          if(!!!gradmID){return res.end()};
          groupadmin.get(gradmID, {userID:1}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":groupadmin get: "+e})};
            if(!!!r){return errResponse(reason.roleError, body, res)};
            users.get(userID, {groupAdminUserID: 1}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":user get: "+e})};
              var firedID = r.groupAdminUserID;
              groupadmin.delMember(firedID, userID, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":groupadmin delMember: "+e})};
              });
              groupadmin.addMember(gradmID, userID, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":groupadmin addMember: "+e})};
              });
              users.update(userID,{groupAdminUserID: gradmID}, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":user update: "+e})};
              });
              body.result = true;
              res.json(body);
            }); // users.get
          }) // groupadmin.get
        break;
        case 'getAll':
          var query = req.body.query || {};
          groupadmin.getList(query,{members:0},function(e,arr){
            if(e){return res.status(500).json({error: "API:"+api+":groupadmin getList: "+e})};
            body.result = true;
            body.groupadmin = arr;
            res.json(body);            
          });
        break;
//        case '':
//        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
// 2
    } // if-else
  }); // session validation
}


exports.operatePendant = function(req, res){
  var api = 'operatePendant'
    , sessID = req.headers.auth
    , operand // // valid values: 'create', 'cancel', 'decline', 'approve', 'remove', 'getUserPendants', 'getAssignedPendants', 'get', 'getby'
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;
//------------------------------------------------------

/* // Pendant description
pendants = {
  pndID: ,
  userID: , // Creator 
  loanAppID: ,
  loanUserID: ,
  clctAppID: ,
  clctUserID: ,
  amount: ,
  type: , // 'loan' or 'collect'
  status: , // 'offered', 'approved' or 'declined'
  overdueDate: date + pndActivePeriod,
  creationDate: date
}
*/

  var d = new Date()
    , pndActivePeriod = require('config').pendantProperties.activePeriod
    , filter = req.body.filter || {} // filter for 'get' and 'getby' operands
    , query = req.body.query || {} // select (find) query for getby operand
  ;
// Helpers
  var pndIDResponse = function(c, b, r){
        if(c === 0){
          b.result = b.pndID.length > 0 ? true : false;
          r.json(b);
        }      
      }
    ;

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
    } else { // sessID is OK
      switch(operand){
/*** create ***
* 1. pendant is an Object {loanAppID, clctAppID,amount, type}.
* 2. Type is 'loan' or 'collect'
* 3. If type is 'loan' - update the loanAppID
* 4. clctAppID is always updated.
* 5. Returns Array of pendants.
***/
        case 'create':
        var pnd = req.body.pendant || {};
          if(!!!Object.keys(pnd).length){return res.end()};
          if(!!!pnd.amount     ||
             !!!pnd.loanAppID  ||
             !!!pnd.clctAppID  ||
             !!!pnd.type){return res.end()};
          pnd.amount = Number(pnd.amount); // custing
          pnd.status = 'offered';
          pnd.userID = userID;
          pnd.creationDate = d.getTime();
          pnd.overdueDate = d.setDate(d.getDate() + pndActivePeriod);
          applications.getMany([pnd.loanAppID, pnd.clctAppID], {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
            if(!!!r || r.length !== 2){return res.end()};
            var loan = r.find(function(el){return el.appID === pnd.loanAppID}) || false
              , clct = r.find(function(el){return el.appID === pnd.clctAppID}) || false;
            if(!!!loan || !!!clct){return res.end()};
            if(pnd.type === 'loan' && loan.balance < pnd.amount){return errResponse(reason.invalidAmount, body, res)};
            pnd.loanUserID = loan.userID;
            pnd.clctUserID = clct.userID;
            count.get('pndID', function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":count.get: "+e})};
              pnd.pndID = r.value.seq;
              pendants.insert(pnd, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.insert: "+e})};
                delete pnd._id;
                body.pendant = pnd;
                // LOAN application
                if(pnd.type === 'loan'){
                  loan.pending += pnd.amount;
                  loan.balance -= pnd.amount;                    
                  loan.pendants.push(pnd.pndID);
                  applications.update(pnd.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                } // pnd.type === 'loan'
                // COLLECT application
                clct.pendants.push(pnd.pndID);
                applications.update(pnd.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
                body.result = true;
                res.json(body);
              }); //pendants.insert
            }); //count.get            
          }); // application.getPair 
        break; //create

/*** cancel ***
* 1. The user can cancel only it's own pendants
* 2. If status is 'declined' - just remove the pendant
* 3. If type is 'loan' or status is 'approved' - update the loan application
* 4. Always update the collect application.
***/
        case 'cancel':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if(!!!p || p.userID !== userID){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.status !== 'declined'){
                if(p.type === 'loan' || p.status === 'approved'){
                  // LOAN application
                  loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                  loan.pending -= Number(p.amount);
                  loan.balance += Number(p.amount);
                  applications.update(p.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                } // p.type === 'loan' || p.status === 'approved'. 
                // COLLECT application
                clct.pendants.splice(clct.pendants.indexOf(pnd),1);
                applications.update(p.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.status !== 'declined'. When 'declined' - this has already done.
              pendants.remove(pnd, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                // send message to the appropriate userID
              }); // pendants.remove
              body.pndID = pnd;
              body.result = true;
              res.json(body);
            }); // applications.getMany
          }); // pendants.get
        break; // cancel

/*** approve ***
* 1. Process only 'offered' status.
* 2. If the type is 'loan' just set a status as 'approved'
* 3. If the type is 'collect' - update the loan application and set a status.
***/
        case 'approve':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if( !!!p
                || p.status !== 'offered'
                || userID !== (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't approve its own pendant.
              ){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.type === 'collect' && loan.balance < p.amount){return errResponse(reason.invalidAmount, body, res)};
              if(p.type === 'collect'){
                loan.pending += p.amount;
                loan.balance -= p.amount;                    
                loan.pendants.push(pnd);
                applications.update(p.loanAppID, loan, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.type === 'collect'
              pendants.updateStatus(pnd, 'approved', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                // send message to the appropriate userID
              });
              p.status = 'approved';
              body.pendant = p;
              body.pndID = pnd;                
              body.result = true;
              res.json(body);
            }); //applications.getMany
          }); // pendants.get
        break; // approve

/*** decline ***
* 1. It is possible to decline already approved application.
* 2. The pendant is removed from the application's list. From loan and from collect applications
* 3. The status is set as 'declined'
* 4. User can remove it's declined pendants.
***/
        case 'decline':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if( !!!p
                || p.status !== 'offered'  // It is possible to decline only offered pendant.
                || userID !== (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't decline its own pendant.
              ){return res.end()}; 
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.type === 'loan'){                  
                loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                loan.pending -= p.amount;
                loan.balance += p.amount;
                applications.update(p.loanAppID, loan, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.type === 'loan'
              clct.pendants.splice(clct.pendants.indexOf(pnd),1);
              applications.update(p.clctAppID, clct, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
              });
              pendants.updateStatus(pnd, 'declined', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                // send message to appropriate userID.
              });
              p.status = 'declined';
              body.pendant = p;
              body.pndID = pnd;                
              body.result = true;
              res.json(body);
            }); //p.loanAppID
          }); // pendants.get
        break; // decline

/*** remove ***
* 1. The only operand that assepts array.
* 2. User can remove only it's declined pendants
***/
        case 'remove': // Only for declined pendants
          var pndID = req.body.pndID || [];
          if(!!!Array.isArray(pndID)){pndID = [pndID]};
          pendants.removeDeclined(userID, pndID, function(e){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.removeDeclined: "+e})};
            body.pndID = pndID;                
            body.result = true;
            res.json(body);            
          }); // pendants.removeDeclined
        break; // remove
/*** getUserPendants and getAssignedPendants ***
*  Return list of user related pendants.
***/
        case 'getUserPendants':
          pendants.getUserPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getUserPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true: false;
            res.json(body);
          });
        break;
        case 'getAssignedPendants':
          pendants.getAssignedPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getAssignedPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true : false;
            res.json(body);
          });
        break;        
/*** get and getby ***
* General APIs for DB queries
***/
        case 'get':
          var pndID = req.body.pndID || 0;
          if(!!!pndID){return res.end()};
          pendants.get(pndID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":get: "+e})};
            body.result = r ? true : false;
            if(r){
              body.pndID = pndID;
              body.pendant = r;
            } else {
              body.reason = reason.notFoundInDB;              
            };
            res.json(body);
          });
        break;
        case 'getby':
          pendants.getBy(query, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":getby: "+e})};
            body.result = r.length ? true : false;
            if(r.length){
              body.pndID = r.map(function(el){return el.pndID});
              body.pendant = r;
            } else {
              body.reason = reason.notFoundInDB;              
            }
            res.json(body);
          });
        break;        
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
    } // if-else
  }); // session validation
}

exports.operatePlan = function(req, res){
  var api = 'operatePlan'
    , permissions = ['businessAdmin'] // Required permissions for the API execution
    , sessID = req.headers.auth
    , operand // valid values: 'create', 'update', 'delete', 'get'
    , body = {}
    , userID = Number(req.body.userID || 0)
    ;
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  var planID = req.body.planID || []
    , plan = req.body.plan || []
    , filter = req.body.filter || {} // filter for 'get' API
    , d = new Date()
    ;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand; 
  if(!!!Array.isArray(plan)){plan = [].concat(plan)};
  if(!!!Array.isArray(planID)){planID = [].concat(planID)};

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      body.plan = [];
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      body.plan = [];
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // user validation
      users.get(userID, {'userRole':1}, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+":user role: "+e})};
        if(!!!r){return res.end()};
        if(r.userRole.some(function(el){
                            return permissions.indexOf(el) > -1;}
                          )
          ){ // user has permission
          switch(operand){
            case 'create':
              var counter = plan.length;
              body.plan = [];
              plan.forEach(function(pln){
                count.get('planID', function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                  pln.planID = r.value.seq;
                  plans.insert(pln, function(e,r){
                    if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                    delete pln._id;
                    body.plan.push(pln);
                    if(--counter === 0){
                      if(body.plan.length === 1){body.plan = body.plan.shift()}
                      body.result = true;
                      res.json(body);
                    }
                  });
                });
              })
            break;
            case 'update':
              var counter = plan.length;
              body.plan = [];
              plan.forEach(function(pln){
                plans.update(pln.planID, pln, function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                  delete pln._id;
                  body.plan.push(pln);
                  if(--counter === 0){
                    if(body.plan.length === 1){body.plan = body.plan.shift()}
                      body.result = true;
                      res.json(body);
                  }
                });
              });
            break;
            case 'remove':
              var counter = planID.length;
              planID.forEach(function(pln){
                plans.remove(pln, function(e,r){
                  if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                  if(--counter === 0){
                    if(planID.length === 1){planID = planID.shift()}
                    body.result = true;
                    body.planID = planID;
                    res.json(body);
                  }
                });
              });
            break;
            case 'get':
              planID = planID.shift(); // Extract planID from the List
              plans.get(planID, filter, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+": "+e})};
                body.result = true;
                body.planID = planID;
                body.plan = r;
                res.json(body);
              })
            break;
            default:
              res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
          } // switch()
        } else { // user doesn't have permission
          body.plan = [];
          return errResponse(reason.permissionDenied, body, res);
//          body.result = false;
//          body.reason = 'permission_denied';
//          res.json(body);
        }
      }); // users.get
    } // if-else
  }); // session.validate()
}


exports.operateTransaction = function(req, res){
  var api = 'operateTransaction'
    , sessID = req.headers.auth
    , operand // valid values: all
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;

  var d = new Date()
    , transActivePeriod = require('config').transactionProperties.activePeriod
    , transID = req.body.transID || []
  ;
  if(!!!Array.isArray(transID)){transID = [transID]};

/* // Transaction description 
transactions = {
  transID: ,
  loanUserID: ,
  loanAppID: ,
  clctUserID: ,
  clctAppID: ,
  payMeans: '', // provided by clctUserID
  amount: ,
  status: , // 'active', 'completed' or 'canceled'
  messages: [{from: '', text: '', creationDate: date}, {}],
  creationDate: date,
  overdueDate: date,
  commitedDate: date
}

*/
  
//19
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // sessID is OK
      switch(operand){
/*** create ***
* 1. Only one transaction at a time. Array is not supproted
* 2. Only clctUserID can create the transaction.
* 3. The transaction can be created only from approved pendant.
* 4. LOAD application
*   - Remove pndID from pendants[]
*   - Add transID, amount and status to transactions[]
* 5. COLLECT application
*   - Remove pndID from pendants[]
*   - Add transID, amount and status to transactions[]
*   - Substract transaction amount from the application balance
*   - If the balance is 0 then set the status to 'completed'
* 6. Create transaction  
* 7. Remove pendant
***/
        case 'create':
          var pndID = req.body.pndID || 0
            , payMeans = req.body.payMeans || {};
          if(!!!pndID || !!!Object.keys(payMeans).length){return res.end()};
          pendants.get(pndID,{},function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if(!!!p || p.status !== 'approved' || p.clctUserID !== userID){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(clct.balance < p.amount){return errResponse(reason.invalidAmount, body, res)};
              count.get('transID', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":count.get: "+e})};
                var transID = r.value.seq
                  , transaction = {
                      transID: transID,
                      loanUserID: p.loanUserID,
                      loanAppID: p.loanAppID,
                      clctUserID: p.clctUserID,
                      clctAppID: p.clctAppID,
                      amount: p.amount,
                      payMeans: payMeans,
                      status: 'active', // 'active', 'completed' or 'canceled'
                      messages: [], // [{from: '', text: '', creationDate: date, status: 'read|unread'}, {}],
                      creationDate: d.getTime(),
                      overdueDate: d.setDate(d.getDate() + transActivePeriod),
                      commitedDate: 0
                    };
                transactions.insert(transaction, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":transactions.insert: "+e})};
                  delete transaction._id;
                  // Send notification to p.loanUserID.

                  // LOAN application
                  loan.pendants.splice(loan.pendants.indexOf(pndID),1); // delete pndID from pendants[]
                  loan.transactions.push({transID:transID, amount:p.amount, status:'active'}); // add transID, amount and status to transactions
                  applications.update(p.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                  // COLLECT application
                  clct.pendants.splice(clct.pendants.indexOf(pndID),1); // delete pndID from pendants[]
                  clct.transactions.push({transID:transID, amount:p.amount, status:'active'}); // add transID, amount and status to transactions
                  clct.balance -= p.amount; // substract transaction amount from application amount.
                  if(clct.balance === 0){clct.status = 'completed'};
                  applications.update(p.clctAppID, clct, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                  // Pendant
                  pendants.remove(pndID, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                  });
                  // Response
                  body.result = true;
                  body.transaction = transaction;
                  body.transID = transID;
                  res.json(body);
                }); // transactions.insert
              }); // count.get('transID')
            }); // applications.getMany
          }); // pendants.get 
        break;
/*** approve ***
* 1. Only one transaction at a time. Array is not supproted
* 2. Only clctUserID can approve the transaction.
* 3. LOAN application
*   - The transaction amount is moved from the application pending to the asset (app.asset += trans.amount).
*   - If the asset is equal to amount then set the application status to 'completed'.
* 4. COLLECT application
*   - if the status is 'completed' then archive the application.
* 5. Transaction
*   - Set the transaction status to 'completed' and archive the transaction.
***/
        case 'approve':
          var transID = req.body.transID || 0;
          if(!!!transID){return res.end()};
          transactions.get(transID, {}, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            if(t.clctUserID !== userID){return res.end()};
            applications.getMany([t.loanAppID, t.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === t.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === t.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()};
              if(loan.pending < t.amount){return errResponse(reason.invalidAmount, body, res)};
              // LOAN application
              loan.asset += t.amount;
              loan.pending -= t.amount;
              if(loan.asset === loan.amount){loan.status = 'completed'};
              loan.transactions.forEach(function(el){if(el.transID === transID){el.status = 'completed'}});
              applications.update(t.loanAppID, loan, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
              });
              // COLLECT application
              clct.transactions.forEach(function(el){if(el.transID === transID){el.status = 'completed'}});
              if(clct.status === 'completed'){ // Archve the application
                delete clct.pendants;
                delete clct.weight;
                delete clct.balance;
                clct.creationDate = d.getTime();
                apparchive.insert(clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":apparchive.insert: "+e})};                    
                  applications.remove(t.clctAppID, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.remove: "+e})};                        
                  });
                });
              } else {; // clct.status === 'completed'
                application.update(t.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                                          
                });
              }
              //TRANSACTION
              t.status = 'completed';
              t.commitedDate = d.getTime();
              transarchive.insert(t, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":transarchive.insert: "+e})};                                      
                transactions.remove(t.transID, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":transaction.remove: "+e})};                                      
                });                  
              });
              body.result = true;
              body.transaction = t;
              body.transID = transID;
              res.json(body);
            }); // applications.getMany
          }); // transactions.get(transID)
        break;

        case 'get':
          var transID = req.body.transID || 0;
          if(!!!transID){return res.end()};
          transactions.get(transID, {}, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.result = true;
            body.transaction = t;
            body.transID = transID;
            res.json(body);
          }); // transactions.get(transID)
        break;
/*** getActiveTransactions ***
* returns array of transactions related to userID from transactions table 
***/
        case 'getActiveTransactions':
          var filter = req.body.filter || {};
          transactions.getUserTransactions(userID, filter, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.result = true;
            body.transaction = t;
            body.transID = t.map(function(el){return el.transID});
            res.json(body);
          }); // transactions.get(transID)
        break;
/*** getUserTransactions ***
* returns array of transactions related to userID from transactions and transarchive tables 
***/
        case 'getUserTransactions':
          var filter = req.body.filter || {};
          transactions.getUserTransactions(userID, filter, function(e,tr){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.transID = tr.map(function(el){return el.transID});
            transarchive.getUserTransactions(userID, filter, function(e,ta){
              if(e){return res.status(500).json({error: "API:"+api+":transarchive.get: "+e})};
              body.result = true;
              body.transaction = tr.concat(ta);
              body.transID = body.transID.concat(ta.map(function(el){return el.transID}));
              res.json(body);            
            }); // transarchive.get(transID)
          }); // transactions.get(transID)
        break;
        case 'sendMessage':
          var transID = req.body.transID || 0
            , message = {text: req.body.text || '',
                         attachment: req.body.attachment || [],
                         creationDate: d.getTime()
                        }
            ;
          if (!!!transID){return res.end()};
          users.get(userID,{firstName:1, familyName:1}, function(e,u){
            if(e){return res.status(500).json({error: "API:"+api+":users.get: "+e})};
            message.from = u.firstName + ' ' + u.familyName;
            transactions.get(transID, {messages:1}, function(e,t){
              if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
              t.messages.push(message);
              transactions.update(transID, t, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":transactions.update: "+e})};
                body.result = true;
                res.json(body);                            
              }); // transactions.update
            }); // transactions.get
          }); // users.get
        break;
//        case '':
//        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
// 2
    } // if-else
  }); // session validation
}


exports.operateUser = function(req, res){
  var api = 'operateUser'
    , sessID = req.headers.auth
    , operand // valid values: 'get', 'update', 'updateUserRating'
    , userID = Number(req.body.userID || 0)
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  var data = req.body.data || {} // user data for update and updateUserRating APIs
    , filter = req.body.filter || {} // filter for get API
    , d = new Date()
    ;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;
  body.sessID = sessID;

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // sessID is OK
      switch (operand){
        case 'get':
          users.get(userID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            body.result = true;
            body.userID = userID;
            body.user = r;
            res.json(body);
          });
        break;
        case 'update':
          users.update(userID, data, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+": "+e})};
            body.result = true;
            body.userID = userID;
            res.json(body);
          });
        break;
        case 'updateUserRating':
          if(((data.userID || 0) === 0) || ((data.score || 0) === 0)){
            return errResponse(reason.invalidParameters, body, res);
//            body.result = false;
//            body.reason = 'invalid_parameters';
//            res.json(body);
          } else {
            users.updateUserRating(data.userID, data.score, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              body.result = true;
              body.data = {userID: data.userID, userRating: r.value.userRating};
              res.json(body);
            });
          }
        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"})
        ;
      }
    } // if-else
  }); // session validation
}


exports.setLang = function(req, res){
  var api = 'setlang'
    , body = {};
  if(req.headers.auth === undefined ||
     req.headers.auth !== api){return res.end();}

  var lang = req.body.lang || '';
  if(lang === ''){return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', api);
//------------------------------------------------------

  body.lang = lang;
  body.direction = trans.init(lang).direction();
  body.result = true;
  return res.json(body);
}


exports.test = function(req, res){
//console.log(req.headers);
  var body = req.body;
  body.headers = req.headers;
  body.api = 'test';
  body.result = 'OK';
  res.set('Content-Type', 'application/json');
  res.set('Auth', '__SessID__:_aksdjfhlaskdghlasdkhlakfhldksjhalskjdghlp89w34ytasdfarvhpiuweyrtpaihdsjknva');
  res.json(body);
};


exports.updateUserRole = function(req, res){
  var api = 'updateUserRole'
    , sessID = req.headers.auth
    , body = {}
    , userID = Number(req.body.userID || 0)
    ;
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  var data = req.body.data || {}
    , d = new Date()
    , permissions = ['globalAdmin'] // Required permissions for the API execution
    ;

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // user validation
      users.get(userID, {'userRole':1}, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+":user role: "+e})};
        if(r.userRole.some(function(el){return permissions.indexOf(el) > -1;})){ // user has permission
          if(((data.userID || '').length === 0) || ((data.userRole || []).length === 0)){ // no userID or userRole
            return errResponse(reason.invalidParameters, body, res);
//            body.result = false;
//            body.reason = 'invalid_parameters';
//            res.json(body);
          } else { // updateUserRole
            users.updateUserRole(data.userID, data.userRole, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+": "+e})};
              body.result = true;
              res.json(body);
            })
          };
        } else { // user doesn't have permission
          return errResponse(reason.permissionDenied, body, res);
//          body.result = false;
//          body.reason = 'permission_denied';
//          res.json(body);
        }
      }); // users.get
    } // if-else
  }); // session.validate()
}


exports.validate = function(req, res){
  var api = 'validate'
    , sessID = req.headers.auth;
  if ( sessID === undefined ||
       sessID !== req.body.sessID ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
//------------------------------------------------------
  var email = req.body.email || ''
    , passw = req.body.password || ''
    ;

  ldap.validate(email, passw, function(data){
    data.sessID = sessID;
    if(data.result){
      session.update(sessID, function(e,r){
        if(e){return res.status(500).json({error: "API:"+api+": "+e})};
        res.json(data);
      });
    } else {
      res.json(data);
    }
  });
}

