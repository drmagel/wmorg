exports.operatePendant = function(req, res){
  var api = 'operatePendant'
    , sessID = req.headers.auth
    , operand // // valid values: 'create', 'cancel', 'decline', 'approve', 'remove', 'getUserPendants', 'getAssignedPendants', 'get', 'getby'
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;
//------------------------------------------------------

/* // Pendant description
pendants = {
  pndID: ,
  userID: , // Creator 
  loanAppID: ,
  loanUserID: ,
  clctAppID: ,
  clctUserID: ,
  amount: ,
  type: , // 'loan' or 'collect'
  status: , // 'offered', 'approved' or 'declined'
  overdueDate: date + pndActivePeriod,
  creationDate: date
}
*/

  var d = new Date()
    , pndActivePeriod = require('config').pendantProperties.activePeriod
    , filter = req.body.filter || {} // filter for 'get' and 'getby' operands
    , query = req.body.query || {} // select (find) query for getby operand
  ;
// Helpers
  var pndIDResponse = function(c, b, r){
        if(c === 0){
          b.result = b.pndID.length > 0 ? true : false;
          r.json(b);
        }      
      }
    ;

  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
    } else { // sessID is OK
      switch(operand){
/*** create ***
* 1. pendant is an Object {loanAppID, clctAppID,amount, type}.
* 2. Type is 'loan' or 'collect'
* 3. If type is 'loan' - update the loanAppID
* 4. clctAppID is always updated.
* 5. Returns Array of pendants.
***/
        case 'create':
        var pnd = req.body.pendant || {};
          if(!!!Object.keys(pnd).length){return res.end()};
          if(!!!pnd.amount     ||
             !!!pnd.loanAppID  ||
             !!!pnd.clctAppID  ||
             !!!pnd.type){return res.end()};
          pnd.amount = Number(pnd.amount); // custing
          pnd.status = 'offered';
          pnd.userID = userID;
          pnd.creationDate = d.getTime();
          pnd.overdueDate = d.setDate(d.getDate() + pndActivePeriod);
          applications.getMany([pnd.loanAppID, pnd.clctAppID], {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
            if(!!!r || r.length !== 2){return res.end()};
            var loan = r.find(function(el){return el.appID === pnd.loanAppID}) || false
              , clct = r.find(function(el){return el.appID === pnd.clctAppID}) || false;
            if(!!!loan || !!!clct){return res.end()};
            if(pnd.type === 'loan' && loan.balance < pnd.amount){return errResponse(reason.invalidAmount, body, res)};
            pnd.loanUserID = loan.userID;
            pnd.clctUserID = clct.userID;
            count.get('pndID', function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":count.get: "+e})};
              pnd.pndID = r.value.seq;
              pendants.insert(pnd, function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.insert: "+e})};
                delete pnd._id;
                body.pendant = pnd;
                // LOAN application
                if(pnd.type === 'loan'){
                  loan.pending += pnd.amount;
                  loan.balance -= pnd.amount;                    
                  loan.pendants.push(pnd.pndID);
                  applications.update(pnd.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                } // pnd.type === 'loan'
                // COLLECT application
                clct.pendants.push(pnd.pndID);
                applications.update(pnd.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
                body.result = true;
                res.json(body);
              }); //pendants.insert
            }); //count.get            
          }); // application.getPair 
        break; //create

/*** cancel ***
* 1. The user can cancel only it's own pendants
* 2. If status is 'declined' - just remove the pendant
* 3. If type is 'loan' or status is 'approved' - update the loan application
* 4. Always update the collect application.
***/
        case 'cancel':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if(!!!p || p.userID !== userID){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.status !== 'declined'){
                if(p.type === 'loan' || p.status === 'approved'){
                  // LOAN application
                  loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                  loan.pending -= Number(p.amount);
                  loan.balance += Number(p.amount);
                  applications.update(p.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                } // p.type === 'loan' || p.status === 'approved'. 
                // COLLECT application
                clct.pendants.splice(clct.pendants.indexOf(pnd),1);
                applications.update(p.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.status !== 'declined'. When 'declined' - this has already done.
              pendants.remove(pnd, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                // send message to the appropriate userID
              }); // pendants.remove
              body.pndID = pnd;
              body.result = true;
              res.json(body);
            }); // applications.getMany
          }); // pendants.get
        break; // cancel

/*** approve ***
* 1. Process only 'offered' status.
* 2. If the type is 'loan' just set a status as 'approved'
* 3. If the type is 'collect' - update the loan application and set a status.
***/
        case 'approve':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if( !!!p
                || p.status !== 'offered'
                || userID !== (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't approve its own pendant.
              ){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.type === 'collect' && loan.balance < p.amount){return errResponse(reason.invalidAmount, body, res)};
              if(p.type === 'collect'){
                loan.pending += p.amount;
                loan.balance -= p.amount;                    
                loan.pendants.push(pnd);
                applications.update(p.loanAppID, loan, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.type === 'collect'
              pendants.updateStatus(pnd, 'approved', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                // send message to the appropriate userID
              });
              p.status = 'approved';
              body.pendant = p;
              body.pndID = pnd;                
              body.result = true;
              res.json(body);
            }); //applications.getMany
          }); // pendants.get
        break; // approve

/*** decline ***
* 1. It is possible to decline already approved application.
* 2. The pendant is removed from the application's list. From loan and from collect applications
* 3. The status is set as 'declined'
* 4. User can remove it's declined pendants.
***/
        case 'decline':
          var pnd = req.body.pndID || 0;
          if(!!!pnd){return res.end()};
          pendants.get(pnd, {}, function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if( !!!p
                || p.status !== 'offered'  // It is possible to decline only offered pendant.
                || userID !== (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't decline its own pendant.
              ){return res.end()}; 
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(p.type === 'loan'){                  
                loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                loan.pending -= p.amount;
                loan.balance += p.amount;
                applications.update(p.loanAppID, loan, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                });
              } // p.type === 'loan'
              clct.pendants.splice(clct.pendants.indexOf(pnd),1);
              applications.update(p.clctAppID, clct, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
              });
              pendants.updateStatus(pnd, 'declined', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                // send message to appropriate userID.
              });
              p.status = 'declined';
              body.pendant = p;
              body.pndID = pnd;                
              body.result = true;
              res.json(body);
            }); //p.loanAppID
          }); // pendants.get
        break; // decline

/*** remove ***
* 1. The only operand that assepts array.
* 2. User can remove only it's declined pendants
***/
        case 'remove': // Only for declined pendants
          var pndID = req.body.pndID || [];
          if(!!!Array.isArray(pndID)){pndID = [pndID]};
          pendants.removeDeclined(userID, pndID, function(e){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.removeDeclined: "+e})};
            body.pndID = pndID;                
            body.result = true;
            res.json(body);            
          }); // pendants.removeDeclined
        break; // remove
/*** getUserPendants and getAssignedPendants ***
*  Return list of user related pendants.
***/
        case 'getUserPendants':
          pendants.getUserPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getUserPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true: false;
            res.json(body);
          });
        break;
        case 'getAssignedPendants':
          pendants.getAssignedPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getAssignedPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true : false;
            res.json(body);
          });
        break;        
/*** get and getby ***
* General APIs for DB queries
***/
        case 'get':
          var pndID = req.body.pndID || 0;
          if(!!!pndID){return res.end()};
          pendants.get(pndID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":get: "+e})};
            body.result = r ? true : false;
            if(r){
              body.pndID = pndID;
              body.pendant = r;
            } else {
              body.reason = reason.notFoundInDB;              
            };
            res.json(body);
          });
        break;
        case 'getby':
          pendants.getBy(query, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":getby: "+e})};
            body.result = r.length ? true : false;
            if(r.length){
              body.pndID = r.map(function(el){return el.pndID});
              body.pendant = r;
            } else {
              body.reason = reason.notFoundInDB;              
            }
            res.json(body);
          });
        break;        
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
    } // if-else
  }); // session validation
}
