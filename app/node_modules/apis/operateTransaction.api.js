exports.operateTransaction = function(req, res){
  var api = 'operateTransaction'
    , sessID = req.headers.auth
    , operand // valid values: all
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
//------------------------------------------------------
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;

  var d = new Date()
    , transActivePeriod = require('config').transactionProperties.activePeriod
    , transID = req.body.transID || []
  ;
  if(!!!Array.isArray(transID)){transID = [transID]};

/* // Transaction description 
transactions = {
  transID: ,
  loanUserID: ,
  loanAppID: ,
  clctUserID: ,
  clctAppID: ,
  payMeans: '', // provided by clctUserID
  amount: ,
  status: , // 'active', 'completed' or 'canceled'
  messages: [{from: '', text: '', creationDate: date}, {}],
  creationDate: date,
  overdueDate: date,
  commitedDate: date
}

*/
  
//19
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
//      body.result = false;
//      body.reason = 'invalid_sessid';
//      res.json(body);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
//      body.result = false;
//      body.reason = 'sessid_expired';
//      res.json(body);
    } else { // sessID is OK
      switch(operand){
/*** create ***
* 1. Only one transaction at a time. Array is not supproted
* 2. Only clctUserID can create the transaction.
* 3. The transaction can be created only from approved pendant.
* 4. LOAD application
*   - Remove pndID from pendants[]
*   - Add transID, amount and status to transactions[]
* 5. COLLECT application
*   - Remove pndID from pendants[]
*   - Add transID, amount and status to transactions[]
*   - Substract transaction amount from the application balance
*   - If the balance is 0 then set the status to 'completed'
* 6. Create transaction  
* 7. Remove pendant
***/
        case 'create':
          var pndID = req.body.pndID || 0
            , payMeans = req.body.payMeans || {};
          if(!!!pndID || !!!Object.keys(payMeans).length){return res.end()};
          pendants.get(pndID,{},function(e,p){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
            if(!!!p || p.status !== 'approved' || p.clctUserID !== userID){return res.end()};
            applications.getMany([p.loanAppID, p.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === p.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === p.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()}
              if(clct.balance < p.amount){return errResponse(reason.invalidAmount, body, res)};
              count.get('transID', function(e,r){
                if(e){return res.status(500).json({error: "API:"+api+":count.get: "+e})};
                var transID = r.value.seq
                  , transaction = {
                      transID: transID,
                      loanUserID: p.loanUserID,
                      loanAppID: p.loanAppID,
                      clctUserID: p.clctUserID,
                      clctAppID: p.clctAppID,
                      amount: p.amount,
                      payMeans: payMeans,
                      status: 'active', // 'active', 'completed' or 'canceled'
                      messages: [], // [{from: '', text: '', creationDate: date, status: 'read|unread'}, {}],
                      creationDate: d.getTime(),
                      overdueDate: d.setDate(d.getDate() + transActivePeriod),
                      commitedDate: 0
                    };
                transactions.insert(transaction, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":transactions.insert: "+e})};
                  delete transaction._id;
                  // Send notification to p.loanUserID.

                  // LOAN application
                  loan.pendants.splice(loan.pendants.indexOf(pndID),1); // delete pndID from pendants[]
                  loan.transactions.push({transID:transID, amount:p.amount, status:'active'}); // add transID, amount and status to transactions
                  applications.update(p.loanAppID, loan, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                  // COLLECT application
                  clct.pendants.splice(clct.pendants.indexOf(pndID),1); // delete pndID from pendants[]
                  clct.transactions.push({transID:transID, amount:p.amount, status:'active'}); // add transID, amount and status to transactions
                  clct.balance -= p.amount; // substract transaction amount from application amount.
                  if(clct.balance === 0){clct.status = 'completed'};
                  applications.update(p.clctAppID, clct, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                  });
                  // Pendant
                  pendants.remove(pndID, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                  });
                  // Response
                  body.result = true;
                  body.transaction = transaction;
                  body.transID = transID;
                  res.json(body);
                }); // transactions.insert
              }); // count.get('transID')
            }); // applications.getMany
          }); // pendants.get 
        break;
/*** approve ***
* 1. Only one transaction at a time. Array is not supproted
* 2. Only clctUserID can approve the transaction.
* 3. LOAN application
*   - The transaction amount is moved from the application pending to the asset (app.asset += trans.amount).
*   - If the asset is equal to amount then set the application status to 'completed'.
* 4. COLLECT application
*   - if the status is 'completed' then archive the application.
* 5. Transaction
*   - Set the transaction status to 'completed' and archive the transaction.
***/
        case 'approve':
          var transID = req.body.transID || 0;
          if(!!!transID){return res.end()};
          transactions.get(transID, {}, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            if(t.clctUserID !== userID){return res.end()};
            applications.getMany([t.loanAppID, t.clctAppID], {}, function(e,r){
              if(e){return res.status(500).json({error: "API:"+api+":applications.getMany: "+e})};
              if(!!!r || r.length !== 2){return res.end()};
              var loan = r.find(function(el){return el.appID === t.loanAppID}) || false
                , clct = r.find(function(el){return el.appID === t.clctAppID}) || false;
              if(!!!loan || !!!clct){return res.end()};
              if(loan.pending < t.amount){return errResponse(reason.invalidAmount, body, res)};
              // LOAN application
              loan.asset += t.amount;
              loan.pending -= t.amount;
              if(loan.asset === loan.amount){loan.status = 'completed'};
              loan.transactions.forEach(function(el){if(el.transID === transID){el.status = 'completed'}});
              applications.update(t.loanAppID, loan, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
              });
              // COLLECT application
              clct.transactions.forEach(function(el){if(el.transID === transID){el.status = 'completed'}});
              if(clct.status === 'completed'){ // Archve the application
                delete clct.pendants;
                delete clct.weight;
                delete clct.balance;
                clct.creationDate = d.getTime();
                apparchive.insert(clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":apparchive.insert: "+e})};                    
                  applications.remove(t.clctAppID, function(e){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.remove: "+e})};                        
                  });
                });
              } else {; // clct.status === 'completed'
                application.update(t.clctAppID, clct, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                                          
                });
              }
              //TRANSACTION
              t.status = 'completed';
              t.commitedDate = d.getTime();
              transarchive.insert(t, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":transarchive.insert: "+e})};                                      
                transactions.remove(t.transID, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":transaction.remove: "+e})};                                      
                });                  
              });
              body.result = true;
              body.transaction = t;
              body.transID = transID;
              res.json(body);
            }); // applications.getMany
          }); // transactions.get(transID)
        break;

        case 'get':
          var transID = req.body.transID || 0;
          if(!!!transID){return res.end()};
          transactions.get(transID, {}, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.result = true;
            body.transaction = t;
            body.transID = transID;
            res.json(body);
          }); // transactions.get(transID)
        break;
/*** getActiveTransactions ***
* returns array of transactions related to userID from transactions table 
***/
        case 'getActiveTransactions':
          var filter = req.body.filter || {};
          transactions.getUserTransactions(userID, filter, function(e,t){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.result = true;
            body.transaction = t;
            body.transID = t.map(function(el){return el.transID});
            res.json(body);
          }); // transactions.get(transID)
        break;
/*** getUserTransactions ***
* returns array of transactions related to userID from transactions and transarchive tables 
***/
        case 'getUserTransactions':
          var filter = req.body.filter || {};
          transactions.getUserTransactions(userID, filter, function(e,tr){
            if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
            body.transID = tr.map(function(el){return el.transID});
            transarchive.getUserTransactions(userID, filter, function(e,ta){
              if(e){return res.status(500).json({error: "API:"+api+":transarchive.get: "+e})};
              body.result = true;
              body.transaction = tr.concat(ta);
              body.transID = body.transID.concat(ta.map(function(el){return el.transID}));
              res.json(body);            
            }); // transarchive.get(transID)
          }); // transactions.get(transID)
        break;
        case 'sendMessage':
          var transID = req.body.transID || 0
            , message = {text: req.body.text || '',
                         attachment: req.body.attachment || [],
                         creationDate: d.getTime()
                        }
            ;
          if (!!!transID){return res.end()};
          users.get(userID,{firstName:1, familyName:1}, function(e,u){
            if(e){return res.status(500).json({error: "API:"+api+":users.get: "+e})};
            message.from = u.firstName + ' ' + u.familyName;
            transactions.get(transID, {messages:1}, function(e,t){
              if(e){return res.status(500).json({error: "API:"+api+":transactions.get: "+e})};
              t.messages.push(message);
              transactions.update(transID, t, function(e){
                if(e){return res.status(500).json({error: "API:"+api+":transactions.update: "+e})};
                body.result = true;
                res.json(body);                            
              }); // transactions.update
            }); // transactions.get
          }); // users.get
        break;
//        case '':
//        break;
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
// 2
    } // if-else
  }); // session validation
}

