exports.operatePendant = function(req, res){
  var api = 'operatePendant'
    , sessID = req.headers.auth
    , operand // // valid values: 'create', 'cancel', 'decline', 'approve', 'remove', 'getUserPendants', 'getAssignedPendants', 'get', 'getby'
    , userID = Number(req.body.userID) || 0
    , body = {};
  if ( sessID === undefined ||
       sessID !== req.body.sessID ||
       userID === 0 ) {return res.end()};
  res.set('Content-Type', 'application/json');
  res.set('Auth', sessID);
  body.sessID = sessID;
  req.query.operand ? operand = req.query.operand : operand = req.body.operand;
//------------------------------------------------------

/* // Pendant description
pendants = {
  pndID: ,
  userID: , // Creator 
  loanAppID: ,
  loanUserID: ,
  clctAppID: ,
  clctUserID: ,
  amount: ,
  type: , // 'loan' or 'collect'
  status: , // 'offered', 'approved' or 'declined'
  overdueDate: date + pndActivePeriod,
  creationDate: date
}
*/

  var d = new Date()
    , pndActivePeriod = require('config').pendantProperties.activePeriod
    , pndID = req.body.pndID || [] // for 'approve', 'decline', 'cancel' and 'remove' operans
    , pendant = req.body.pendant || [] // for 'create' operands
    , filter = req.body.filter || {} // filter for 'get' and 'getby' operands
    , query = req.body.query || {} // select (find) query for getby operand
  ;

  if(!!!Array.isArray(pendant)){pendant = [].concat(pendant)};
  if(!!!Array.isArray(pndID)){pndID = [].concat(pndID)};

// Helpers
  var pendantResponse = function(c, b, r){
        if(c === 0){
          b.result = b.pendant.length > 0 ? true : false;
          r.json(b);
        }                      
      }
    , pndIDResponse = function(c, b, r){
        if(c === 0){
          b.result = b.pndID.length > 0 ? true : false;
          r.json(b);
        }      
      }
    ;
  
  session.get(sessID,{userID:1, validTill:1}, function(e,r){ // session validation
    if(e){return res.status(500).json({error: "API:"+api+":session validation: "+e})};
    if(r === null || r.userID !== userID){ // no sessID or different userID
      return errResponse(reason.invalidSessid, body, res);
    } else if(r.validTill < d.getTime()) { // sessID is expired
      return errResponse(reason.expiredSessid, body, res);
    } else { // sessID is OK
      switch(operand){
/*** create ***
* 1. Array of Objects {loanAppID, loanUserID, clctAppID, clctUserID, amount, type}.
* 2. Type is 'loan' or 'collect'
* 3. If type is 'loan' - update the loanAppID
* 4. clctAppID is always updated.
* 5. Returns Array of pendants.
***/
        case 'create':
          var pndCounter = pendant.length;
          if(!!!pndCounter){return res.end()};
          body.pendant = [];
          pendant.forEach(function(pnd){
            if(!!!pnd.amount     ||
               !!!pnd.loanAppID  ||
               !!!pnd.clctAppID  ||
               !!!pnd.type){
                 pendantResponse(--pndCounter, body, res)
            } else { // pnd.values is OK
              applications.get(pnd.loanAppID, {}, function(e, loan){
                if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                applications.get(pnd.clctAppID, {}, function(e, clct){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                  if(!!!loan || !!!clct){ // apps are OK
                    pendantResponse(--pndCounter, body, res);
                  } else {
                    if(pnd.type === 'loan' && loan.balance < Number(pnd.amount)){
                      pendantResponse(--pndCounter, body, res)
                    } else { // balance and amount are OK
                      count.get('pndID', function(e,r){
                        if(e){return res.status(500).json({error: "API:"+api+":count.get: "+e})};
                        pnd.pndID = r.value.seq;
                        pnd.status = 'offered';
                        pnd.userID = userID;
                        pnd.clctUserID = clct.userID;
                        pnd.loanUserID = loan.userID;
                        pnd.creationDate = d.getTime();
                        pnd.overdueDate = d.setDate(d.getDate() + pndActivePeriod);
                        pendants.insert(pnd, function(e,r){
                          if(e){return res.status(500).json({error: "API:"+api+":pendants.insert: "+e})};
                          delete pnd._id;
                          body.pendant.push(pnd);
                          // LOAN application
                          if(pnd.type === 'loan'){
                            loan.pending += Number(pnd.amount);
                            loan.balance -= Number(pnd.amount);
                            loan.pendants.push(pnd.pndID);
                            applications.update(pnd.loanAppID, loan, function(e){
                              if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                            });
                          } // if(type === 'loan')
                          // COLLECT application
                          clct.pendants.push(pnd.pndID);
                          applications.update(pnd.clctAppID, clct, function(e){
                            if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                          });
                          pendantResponse(--pndCounter, body, res);
                        }); // pendants.insert
                      }); // count.get                                                      
                    } // loan.balance < pnd.amount
                  } // loan && clct
                }); // applications.get(pnd.clctAppID)
              }); // applications.get(pnd.loanAppID)                 
            } // pnd.values
          }); // pendant.forEach
        break; // create

/*** cancel ***
* 1. The user can cancel only it's own pendants
* 2. If status is 'declined' - just remove the pendant
* 3. If type is 'loan' or status is 'approved' - update the loan application
* 4. Always update the collect application.
***/
        case 'cancel':
          var pndCounter = pndID.length;
          if(!!!pndCounter){return res.end()};
          body.pndID = [];
          pndID.forEach(function(pnd){
            pendants.get(pnd, {}, function(e,p){
              if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
              if(!!p && p.userID === userID){
                applications.get(p.loanAppID, {}, function(e,loan){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                  applications.get(p.clctAppID, {}, function(e,clct){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                    if(!!loan && !!clct){
                      body.pndID.push(pnd);
                      if(p.status !== 'declined'){
                        // LOAN application
                        if(p.type === 'loan' || p.status === 'approved'){
                            loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                            loan.pending -= Number(p.amount);
                            loan.balance += Number(p.amount);
                            applications.update(p.loanAppID, loan, function(e){
                              if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                            });                   
                        } // p.type === 'loan' || p.status === 'approved'.
                        // COLLECT application
                        clct.pendants.splice(clct.pendants.indexOf(pnd),1);
                        applications.update(p.clctAppID, clct, function(e){
                          if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                        });                  
                      } // p.status !== 'declined'. When 'declined' - this has already done.
                      pendants.remove(pnd, function(e){
                        if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                        // send message to the appropriate userID
                      }); // pendants.remove
                      pndIDResponse(--pndCounter, body, res);
                    } else {pndIDResponse(--pndCounter, body, res)} // !!loan && !!clct
                  }); // applications.get(p.clctAppID)
                }); // applications.get(p.loanAppID)
              } else {pndIDResponse(--pndCounter, body, res)}; // !!p && p.userID === userID
            }); // pendants.get
          }); // pndID.forEach
        break; // cancel

/*** approve ***
* 1. Process only 'offered' status.
* 2. If the type is 'loan' just set a status as 'approved'
* 3. If the type is 'collect' - update the loan application and set a status.
***/
        case 'approve':
          var pndCounter = pndID.length;
          if(!!!pndCounter){return res.end()}; // must be > 0
          body.pendant = [];
          body.pndID = [];
          pndID.forEach(function(pnd){
            pendants.get(pnd, {}, function(e,p){
              if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
              if(!!p && p.status === 'offered' &&
                 userID === (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't approve its own pendant.
                ){
                applications.get(p.loanAppID, {}, function(e,loan){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                  applications.get(p.clctAppID, {}, function(e,clct){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                    if(!!loan && !!clct){
                      if(p.type === 'collect' && loan.balance < p.amount){
                        pndIDResponse(--pndCounter, body, res);
                      } else {
                        p.status = 'approved';
                        body.pendant.push(p);
                        body.pndID.push(pnd);                
                        pendants.updateStatus(pnd, 'approved', function(e,r){
                          if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                          // send message to the appropriate userID
                        });
                        if(p.type === 'collect'){
                          loan.pending += Number(p.amount);
                          loan.balance -= Number(p.amount);                    
                          loan.pendants.push(pnd);
                          applications.update(p.loanAppID, loan, function(e){
                            if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                          });
                        } // p.type === 'collect'
                        pndIDResponse(--pndCounter, body, res);
                      } // loan.balance < p.amount
                    } else {pndIDResponse(--pndCounter, body, res)}; // !!loan && !!clct
                  });  //clctAppID
                });  //loanAppID
              } else {pndIDResponse(--pndCounter, body, res)}; // p.status === 'offered'
            }); // pendants.get
          }); // pndID.forEach
        break; // approve

/*** decline ***
* 1. It is possible to decline already approved application.
* 2. The pendant is removed from the application's list. From loan and from collect applications
* 3. The status is set as 'declined'
* 4. User can remove it's declined pendants.
***/
        case 'decline':
          var pndCounter = pndID.length;
          if(!!!pndCounter){return res.end()};
          body.pendant = [];
          body.pndID = [];
          pndID.forEach(function(pnd){
            pendants.get(pnd, {}, function(e,p){
              if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
              if(!!p && p.status === 'offered' && // It is possible to decline only offered pendant.
                 userID === (p.loanUserID === p.userID ? p.clctUserID : p.loanUserID) // User can't decline its own pendant.
                ){ 
                applications.get(p.loanAppID, {}, function(e,loan){
                  if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                  applications.get(p.clctAppID, {}, function(e,clct){
                    if(e){return res.status(500).json({error: "API:"+api+":applications.get: "+e})};
                    if(!!loan && !!clct){
                      if(p.type === 'loan'){
                        // LOAN application
                        loan.pendants.splice(loan.pendants.indexOf(pnd),1);
                        loan.pending -= Number(p.amount);
                        loan.balance += Number(p.amount);
                        applications.update(p.loanAppID, loan, function(e){
                          if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                        });
                      } // p.type === 'loan'
                      // COLLECT application
                      clct.pendants.splice(clct.pendants.indexOf(pnd),1);
                      applications.update(p.clctAppID, clct, function(e){
                        if(e){return res.status(500).json({error: "API:"+api+":applications.update: "+e})};                        
                      });
                      pendants.updateStatus(pnd, 'declined', function(e,r){
                        if(e){return res.status(500).json({error: "API:"+api+":pendants.updateStatus: "+e})};
                        // send message to appropriate userID.
                      });                             
                      p.status = 'declined';
                      body.pendant.push(p);
                      body.pndID.push(pnd);
                      pndIDResponse(--pndCounter, body, res);
                    } else {pndIDResponse(--pndCounter, body, res)}; // !!loan && !!clct
                  }); // clctAppID
                }); // loanAppID
              } else {pndIDResponse(--pndCounter, body, res)} // p.status !== 'declined' 
            }); // pendants.get
          }); // pndID.forEach
        break; // decline

/*** remove ***
* 1. User can remove only it's declined pendants
***/
        case 'remove': // Only for declined pendants
          var pndCounter = pndID.length;
          if(!!!pndCounter){return res.end()};
          body.pndID = [];
          pndID.forEach(function(pnd){
            pendants.get(pnd, {status:1, userID:1}, function(e,p){
              if(e){return res.status(500).json({error: "API:"+api+":pendants.get: "+e})};
              if(!!p && p.status === 'declined' && p.userID === userID){
                body.pndID.push(pnd);                
                pendants.remove(pnd, function(e){
                  if(e){return res.status(500).json({error: "API:"+api+":pendants.remove: "+e})};
                }); //pendants.remove
                pndIDResponse(--pndCounter, body, res);
              } else {pndIDResponse(--pndCounter, body, res)} // !!p && p.status === 'declined'
            }); // pendants.get
          }); // pndID.forEach
        break; // remove

/*** getUserPendants and getAssignedPendants ***
*  Return list of user related pendants.
***/
        case 'getUserPendants':
          pendants.getUserPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getUserPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true: false;
            res.json(body);
          });
        break;
        case 'getAssignedPendants':
          pendants.getAssignedPendants(userID, {}, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":pendants.getAssignedPendants: "+e})};
            body.pendant = r;
            body.result = r.length > 0 ? true : false;
            res.json(body);
          });
        break;        
/*** get and getby ***
* General APIs for DB queries
***/
        case 'get':
          if(pndID.length !== 1){return res.end()};
          pndID = pndID.shift(); // Extract pndID from the List
          pendants.get(pndID, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":get: "+e})};
            body.result = r ? true : false;
            if(r){
              body.result = true;
              body.pndID = pndID;
              body.pendant = r;
            } else {
              body.result = false;
              body.reason = reason.notFoundInDB;              
            };
            res.json(body);
          });
        break;
        case 'getby':
          pendants.getBy(query, filter, function(e,r){
            if(e){return res.status(500).json({error: "API:"+api+":getby: "+e})};
            if(r.length){
              body.result = true;
              body.pndID = r.map(function(el){return el.pndID});
              body.pendant = r;
            } else {
              body.result = false;
              body.reason = reason.notFoundInDB;              
            }
            res.json(body);
          });
        break;        
        default:
          res.status(500).json({error: "API:"+api+": Operand "+operand+" is not supported"});
      } // switch
    } // if-else
  }); // session validation
}
